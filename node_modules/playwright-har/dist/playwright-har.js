"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlaywrightHar = void 0;
const chrome_har_1 = require("chrome-har");
const fs_1 = require("fs");
const playwright_har_config_1 = require("./playwright-har-config");
class PlaywrightHar {
    constructor(page, config = null) {
        this.addResponseBodyPromises = [];
        this.events = [];
        this.page = page;
        if (config == null) {
            this.config = new playwright_har_config_1.PlaywrightHarConfig();
        }
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            //@ts-ignore
            // newCDPSession is only available for ChromiumBrowserContext
            this.client = yield this.page.context().newCDPSession(this.page);
            yield this.client.send('Page.enable');
            yield this.client.send('Network.enable');
            const observe = [
                'Page.loadEventFired',
                'Page.domContentEventFired',
                'Page.frameStartedLoading',
                'Page.frameAttached',
                'Page.frameScheduledNavigation',
                'Network.requestWillBeSent',
                'Network.requestServedFromCache',
                'Network.dataReceived',
                'Network.responseReceived',
                'Network.resourceChangedPriority',
                'Network.loadingFinished',
                'Network.loadingFailed',
                'Network.getResponseBody'
            ];
            observe.forEach(method => {
                //@ts-ignore
                // Doesn't work when array contains symbols instead of strings
                this.client.on(method, params => {
                    const harEvent = { method, params };
                    this.events.push(harEvent);
                    if (method === 'Network.responseReceived') {
                        if (this.config.recordResponses === false) {
                            return;
                        }
                        const response = harEvent.params.response;
                        const requestId = harEvent.params.requestId;
                        // Response body is unavailable for redirects, no-content, image, audio and video responses
                        if (response.status !== 204 &&
                            response.headers.location == null &&
                            !response.mimeType.includes('image') &&
                            !response.mimeType.includes('audio') &&
                            !response.mimeType.includes('video')) {
                            const addResponseBodyPromise = this.client.send('Network.getResponseBody', { requestId }).then(responseBody => {
                                // Set the response so chrome-har can add it to the HAR file
                                harEvent.params.response = Object.assign(Object.assign({}, response), { body: Buffer.from(responseBody.body, responseBody.base64Encoded ? 'base64' : undefined).toString() });
                            }, reason => { });
                            this.addResponseBodyPromises.push(addResponseBodyPromise);
                        }
                    }
                });
            });
        });
    }
    stop(path) {
        return __awaiter(this, void 0, void 0, function* () {
            yield Promise.all(this.addResponseBodyPromises);
            const harObject = chrome_har_1.harFromMessages(this.events, { includeTextFromResponseBody: this.config.recordResponses !== false });
            this.events = [];
            this.addResponseBodyPromises = [];
            if (path) {
                fs_1.writeFileSync(path, JSON.stringify(harObject));
            }
            else {
                return harObject;
            }
        });
    }
}
exports.PlaywrightHar = PlaywrightHar;
//# sourceMappingURL=playwright-har.js.map